#include "Superfetch.h"
#include "Native.h"

#include <ntstatus.h>

namespace Superfetch
{
	void buildInfo(SuperfetchNative::PSUPERFETCH_INFORMATION superfetchInfo, PVOID buffer, ULONG length, SuperfetchNative::SUPERFETCH_INFORMATION_CLASS infoClass)
	{
		superfetchInfo->Version = SUPERFETCH_VERSION;
		superfetchInfo->Magic = SUPERFETCH_MAGIC;
		superfetchInfo->Data = buffer;
		superfetchInfo->Length = length;
		superfetchInfo->InfoClass = infoClass;
	}

	bool getPhysicalMemoryRanges(std::vector<PhysicalMemoryRange>& ranges)
	{
		SuperfetchNative::PPF_MEMORY_RANGE_INFO_V2 memoryRanges = nullptr;
		SuperfetchNative::SUPERFETCH_INFORMATION sfInfo = { 0 };
		ULONG returnLength = 0;
		SuperfetchNative::PF_MEMORY_RANGE_INFO_V2 memoryRangeInfo = { 0 };
		memoryRangeInfo.version = 2;

		buildInfo(&sfInfo, &memoryRangeInfo, sizeof(memoryRangeInfo), SuperfetchNative::SUPERFETCH_INFORMATION_CLASS::SuperfetchMemoryRangesQuery);

		NTSTATUS status = NtQuerySystemInformation((SuperfetchNative::SYSTEM_INFORMATION_CLASS)SuperfetchNative::SYSTEM_INFORMATION_CLASS::SystemSuperfetchInformation, &sfInfo, sizeof(sfInfo), &returnLength);
		if (status == STATUS_BUFFER_TOO_SMALL) {
			memoryRanges = static_cast<SuperfetchNative::PPF_MEMORY_RANGE_INFO_V2>(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, returnLength));
			memoryRanges->version = 2;
			buildInfo(&sfInfo, memoryRanges, static_cast<ULONG>(returnLength), SuperfetchNative::SUPERFETCH_INFORMATION_CLASS::SuperfetchMemoryRangesQuery);
			status = NtQuerySystemInformation((SuperfetchNative::SYSTEM_INFORMATION_CLASS)SuperfetchNative::SYSTEM_INFORMATION_CLASS::SystemSuperfetchInformation, &sfInfo, sizeof(sfInfo), &returnLength);
			if (status != STATUS_SUCCESS)
				return false;
		}
		else if (status == STATUS_SUCCESS) 
			memoryRanges = &memoryRangeInfo;
		else 
			return false;

		SuperfetchNative::PPHYSICAL_MEMORY_RUN Node;
		for (auto i = 0l; i < memoryRanges->ranges_count; i++)
		{
			Node = reinterpret_cast<SuperfetchNative::PPHYSICAL_MEMORY_RUN>(&memoryRanges->ranges[i]);

			PhysicalMemoryRange range;
			range.start = Node->BasePage << PAGE_SHIFT;
			range.end = (Node->BasePage + Node->PageCount) << PAGE_SHIFT;
			range.pageCount = Node->PageCount;
			range.size = ((Node->PageCount << PAGE_SHIFT) >> 10) * 1024;

			ranges.push_back(range);
		}

		if (memoryRanges != &memoryRangeInfo)
			HeapFree(GetProcessHeap(), 0, memoryRanges);

		return true;
	}
}